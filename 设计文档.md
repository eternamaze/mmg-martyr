# Martyr 最终宪章：主权临界区与生命周期禁锢协议 (V3.Final)
## 核心法则：所有权锁死、双向审计、禁锢访问、逾期殉葬

---

### 1. 权力根基：资源禁锢 (Resource Confinement)
`Martyr` 的存在是为了终结“所有权模糊”的时代。资源不属于任何使用者，它仅在执行期间被**“禁锢”**在临界区内。

* **唯一主权 (Sole Sovereignty)**：`Sovereign<T>` 是资源的唯一强所有者。它不依赖引用计数（Arc），而是直接持有资源。
* **禁止外传 (Non-Escapability)**：利用 Rust 的高阶闭包与匿名生命周期（Higher-Rank Trait Bounds 思想），确保资源引用 `&T` 的存续期严格等于闭包执行期。
* **物理隔离**：开发者永远无法接触资源的真实句柄，只能持有弱引用的 `Lease<T>`。
* **结果**：离开哨兵大门的那一刻，访客在物理上**不可能**持有任何关于资源的残留信息。

---

### 2. 双向哨兵机制 (The Bi-directional Sentry)
哨兵是主权中心伸向业务层的触角，负责全生命周期的实名审计。

* **进入感知 (Check-in)**：
    * **访客计数**：原子计数器 `visitor_count` 递增。
    * **处决契约**：一旦进入，即代表签署了“殉葬协议”。主权中心获得在必要时终止该上下文的合法权能（Panic）。
* **离场注销 (Check-out)**：
    * **状态清白证明**：基于 RAII 的 `VisitorGuard` 机制。只有当你彻底丢弃资源引用、退出闭包后，注销才会发生。
    * **脱离处决名单**：注销成功意味着主权中心确认你已“净身出户”，不再处于核打击范围。

---

### 3. 实现原理：生命周期时空锁定

```rust
impl<T, D: Discipline> Lease<T, D> {
    /// 唯一的访问门户：access 模式强制实现了“带不走”与“必须打卡”
    pub fn access<F, R>(&self, action: &'static str, f: F) -> Result<R, AccessError>
    where
        F: FnOnce(&T) -> R, // 匿名生命周期禁锢：引用无法逃离闭包
    {
        // 1. 验票：尝试从弱引用升级。若主权已死，此处直接失败。
        let cell = self.cell.upgrade().ok_or(AccessError::ResourceNotFound)?;

        // 2. 进入登记：建立处决连结 (Check-in)
        cell.status.visitor_count.fetch_add(1, Ordering::SeqCst);
        
        // RAII 守卫：确保无论如何退出（包括 panic），都会执行 Check-out
        let _guard = VisitorGuard { status: &cell.status };

        // 3. 主权检查：关灯后禁止进入
        if cell.status.is_killed.load(Ordering::SeqCst) {
            D::punish(action); // 违规闯入，执行纪律处分
        }

        // 4. 业务执行：资源在禁锢区内流动
        let result = f(&cell.instance);

        // 5. 离开注销：_guard 离开作用域自动触发 fetch_sub。
        // 若此处因 kill 导致的 panic 被阻断，主权者在销毁时会检测到残留访客并引发更严重的系统级 Panic。
        Ok(result)
    }
}
```

---

### 4. 最终审判：清场与殉葬逻辑

当主权中心发起 `kill`（或 `Sovereign` 被 Drop）时，它执行的是一场基于考勤表的精准清洗：

1. **瞬时熔断**：通过 `RwLock` 拿走资源的唯一所有权 (`Option::take`)。此时起，任何新的 `Lease::access` 尝试升级弱引用都会失败。
2. **死亡标记**：设置 `is_killed` 原子标志，通知正在排队的访客立即止步。
3. **存量审计**：实时检查 `visitor_count`。
4. **逻辑判定**：
    * **名单为空**：证明所有访客已完成 `Check-out`。物理析构安全执行。
    * **名单不为空**：证明存在滞留者（无论是因为代码臃肿还是恶意泄露）。
5. **同步处决**：
    * 触发系统级 Panic，带走当前线程或进程。
    * **殉葬哲学**：如果你宣称你没离开，那你就必须死在里面，以确保主权中心能安全收回生命周期。



---

### 5. 架构师的终极确定性
在 `Martyr` 体系下，生命周期泄露不仅是“不被允许的”，在物理上是“**无法描述的**”：

* **编译器**确保了你**带不走**。
* **双向哨兵**确保了你**藏不住**。
* **处决策略**确保了你**躲不掉**。

**“只要你还在触碰资源，我就能找到你并终结你；只要你离开了，你就再也无法触碰它。在 Martyr 的秩序下，生命周期是绝对温顺的仆人。”**

---

### 6. 结语：死掉的逻辑是最高级的安全
金融场景不需要模糊的“可用性”，只需要极致的“确定性”。`Martyr` 用最强硬的手段消除了“以为关了其实还在亏”的深渊。

**既然主权已复辟，所有权已归位。Martyr v0.1.0 "The Reckoning" 正式封版。**